<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8"/>
  <meta http-equiv="X-UA-Compatible" content="IE=edge"/>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">


  <title>Layout Exemplars</title>

  <script src="../dist/phet-lib.min.js"></script>

  <link rel="shortcut icon" type="image/x-icon" href="../assets/logo-v1.svg">
  <link rel="stylesheet" href="../../sherpa/lib/bootstrap-2.2.2.css">
  <link rel="stylesheet" href="../../sherpa/lib/bootstrap-responsive-2.2.2.css">

  <!-- Before loading other things (that might error), create hooks to report errors/loads for continuous testing -->
  <script src="../../chipper/js/sim-tests/pageload-connector.js"></script>

  <!-- For the styling -->
  <script src="../../sherpa/lib/bootstrap-2.2.2.js"></script>

  <link rel="stylesheet" href="../../sherpa/lib/codemirror-5.52.2.min.css">
  <link rel="stylesheet" href="../../sherpa/lib/codemirror-5.52.2.monokai.min.css">

  <script src="../../sherpa/lib/codemirror-5.52.2.min.js"></script>
  <script src="../../sherpa/lib/codemirror-5.52.2.javascript.min.js"></script>

  <script src="../../scenery/doc/doc.js"></script>
  <link rel="stylesheet" href="../../scenery/doc/doc.css">
  <script src="../../scenery/doc/extractFunctionJS.js"></script>
  <script src="../../scenery/doc/scenery-sandbox.js"></script>
  <link rel="stylesheet" href="../../scenery/doc/scenery-sandbox.css">

  <style>

  </style>

  <script type="text/javascript">
    phet.scenery.Utils.polyfillRequestAnimationFrame();

    _.extend( window, phet.phetCore );
    _.extend( window, phet.axon );
    _.extend( window, phet.dot );
    _.extend( window, phet.kite );
    _.extend( window, phet.scenery );
    _.extend( window, phet.sun );
    _.extend( window, phet.sceneryPhet );

    const colors = [
      new Color( 62, 171, 3 ),
      new Color( 23, 180, 77 ),
      new Color( 24, 183, 138 ),
      new Color( 23, 178, 194 ),
      new Color( 20, 163, 238 ),
      new Color( 71, 136, 255 ),
      new Color( 171, 101, 255 ),
      new Color( 228, 72, 235 ),
      new Color( 252, 66, 186 ),
      new Color( 252, 82, 127 )
    ];
  </script>
</head>

<body>

<div class="row-fluid">
  <div class="span2"></div>
  <div class="span8">
    <div class="page-header" style="text-align: center;">
      <h1>Layout Exemplars</h1>
    </div>
  </div>
  <div class="span2"></div>
</div>

<div class="row-fluid">
  <div class="span2" id="apiList">
    <!-- the apiList will be filled in by JS -->
  </div>
  <div class="span8">

    <p>
      All of the code examples here are editable. You can change the code and see the results immediately.
    </p>

    <h2 id="BasicLayout" class="index">Basic Layout</h2>

    <h3 id="PanelAlignment" class="index">Panel Alignment</h3>

    <p>
      To have a vertical stack of Panels keep the same width, provide <code>stretch: true</code> either on the parent
      container, or on each Panel individually.
    </p>

    <div id="AligningPanels-example"></div>
    <script>
      createSandbox( 'AligningPanels-example', ( scene, stepEmitter ) => {
        // import sun/js/Panel
        // import sun/js/Checkbox
        // import scenery-phet/js/PhetFont

        const resizingRectangle = new Rectangle( {
          fill: 'green',
          rectHeight: 15
        } );

        let elapsedTime = 0;
        stepEmitter.addListener( dt => {
          elapsedTime += dt;

          const minWidth = 30;
          const maxWidth = 200;
          resizingRectangle.rectWidth = ( minWidth + maxWidth ) / 2 + Math.cos( elapsedTime ) * ( maxWidth - minWidth ) / 2;
        } );
        /*START*/

        scene.addChild( new VBox( {
          // This sets the default alignment to stretch (could be provided in each of the
          // Panel's layoutOptions instead)
          stretch: true,

          spacing: 10,
          children: [
            new Panel( new VBox( {
              align: 'left',
              stretch: true,
              spacing: 5,
              children: [
                new Text( 'Checkboxes', { font: new PhetFont( { size: 14, weight: 'bold' } ) } ),
                new Checkbox( new BooleanProperty( false ), new Text( 'First checkbox', {
                  font: new PhetFont( 12 )
                } ), {
                  boxWidth: 14
                } ),
                new Checkbox( new BooleanProperty( false ), new Text( 'Second checkbox', {
                  font: new PhetFont( 12 )
                } ), {
                  boxWidth: 14
                } )
              ]
            } ) ),
            new Panel( new VBox( {
              align: 'left',
              spacing: 5,
              children: [
                new Text( 'Resizing', { font: new PhetFont( { size: 14, weight: 'bold' } ) } ),
                resizingRectangle
              ]
            } ) )
          ]
        } ) );

        /*END*/
      } );
    </script>

    <h3 id="MatchButtonWidths" class="index">Match Button Widths</h3>

    <h3 id="WrapContent" class="index">Wrap Content</h3>
    <p>
      Use <code>wrap: true</code> if you would like content in a FlowBox to wrap onto the next row or column if a string or other dynamic element becomes too long.
      This example shows a panel that acts as a type of legend. As the label width changes for one of the legend entries
      the others wrap accordingly.
    </p>
    <div id="WrapContent-example"></div>

    <script>
      createSandbox( 'WrapContent-example', ( scene, stepEmitter ) => {
        // import scenery-phet/js/PhetFont
        // import sun/js/Panel

        /*START*/
        const earthIcon = new Rectangle( 0, 0, 20, 20, { fill: 'brown' } );
        const earthLabel = new Text( 'Earth', { font: new PhetFont( { size: 14, weight: 'bold' } ) } );

        const waterIcon = new Rectangle( 0, 0, 20, 20, { fill: 'blue' } );
        const waterLabel = new Text( 'Water', { font: new PhetFont( { size: 14, weight: 'bold' } ) } );

        const windIcon = new Rectangle( 0, 0, 20, 20, { fill: 'grey' } );
        const windLabel = new Text( 'Wind', { font: new PhetFont( { size: 14, weight: 'bold' } ) } );

        const fireIcon = new Rectangle( 0, 0, 20, 20, { fill: 'red' } );
        const fireLabel = new Text( 'Fire', { font: new PhetFont( { size: 14, weight: 'bold' } ) } );

        const earth = new HBox( { children: [ earthIcon, earthLabel ], spacing: 5 } );
        const water = new HBox( { children: [ waterIcon, waterLabel ], spacing: 5 } );
        const wind = new HBox( { children: [ windIcon, windLabel ], spacing: 5 } );
        const fire = new HBox( { children: [ fireIcon, fireLabel ], spacing: 5 } );

        const legend = new HBox( {
          children: [ earth, water, wind, fire ],
          wrap: true,
          spacing: 10,
          lineSpacing: 10,
          preferredWidth: 250
        } );

        scene.addChild( legend );
        /*END*/

        let elapsedTime = 0;
        stepEmitter.addListener( dt => {
          elapsedTime += dt;

          const minWidth = 20;
          const maxWidth = 200;
          earthIcon.rectWidth = ( minWidth + maxWidth ) / 2 + Math.cos( elapsedTime ) * ( maxWidth - minWidth ) / 2;
        } );
      } );
    </script>

    <h3 id="ButtonAlignment" class="index">Button Alignment</h3>
    <p>
      Buttons can maintain alignment as their content resizes. This example uses a GridBox and <code>stretch:
      true</code> to align buttons
      in the first column as the width in one of the buttons changes. Notice how the width of the second column is
      unaffected.
    </p>

    <div id="ButtonAlignment-example"></div>
    <script>
      createSandbox( 'ButtonAlignment-example', ( scene, stepEmitter ) => {
        const resizingRectangle = new Rectangle( {
          fill: 'green',
          rectHeight: 15
        } );

        let elapsedTime = 0;
        stepEmitter.addListener( dt => {
          elapsedTime += dt;

          const minWidth = 30;
          const maxWidth = 200;
          resizingRectangle.rectWidth = ( minWidth + maxWidth ) / 2 + Math.cos( elapsedTime ) * ( maxWidth - minWidth ) / 2;
        } );

        /*START*/
        scene.addChild( new GridBox( {
          spacing: 5,
          stretch: true,
          rows: [
            [
              new RectangularPushButton( {
                xAlign: 'stretch',
                yAlign: 'stretch',
                content: new GridBox( {
                  grow: 1,
                  rows: [
                    [
                      new Rectangle( 0, 0, 25, 25, { fill: colors[ 2 ] } ),
                      new Rectangle( 0, 0, 25, 25, { fill: colors[ 4 ] } )
                    ],
                    [
                      new Rectangle( 0, 0, 25, 25, { fill: colors[ 6 ] } ),
                      new Rectangle( 0, 0, 25, 25, { fill: colors[ 8 ] } )
                    ]
                  ]
                } ),
                sizable: true
              } ),
              new RectangularPushButton( {
                content: new Rectangle( 0, 0, 50, 100, { fill: 'red' } ),
                sizable: true
              } )
            ],
            [
              new RectangularPushButton( {
                content: resizingRectangle,
                sizable: true
              } ),
              new RectangularPushButton( {
                content: new Rectangle( 0, 0, 100, 100, { fill: 'red' } ),
                sizable: true
              } )
            ]
          ]
        } ) );

        /*END*/
      } );
    </script>

    <h3 id="ResizableButtons" class="index">Resizable Buttons</h3>

    <p>
      When provided resizing/dynamic content, buttons can automatically adjust to the content's width. By default
      buttons are <code>sizable: true</code>.
    </p>

    <div id="ResizableButtons-example"></div>
    <script>
      createSandbox( 'ResizableButtons-example', ( scene, stepEmitter ) => {
        const resizingRectangle = new Rectangle( {
          fill: 'green',
          rectHeight: 15
        } );

        let elapsedTime = 0;
        stepEmitter.addListener( dt => {
          elapsedTime += dt;

          const minWidth = 30;
          const maxWidth = 200;
          resizingRectangle.rectWidth = ( minWidth + maxWidth ) / 2 + Math.cos( elapsedTime ) * ( maxWidth - minWidth ) / 2;
        } );

        /*START*/
        scene.addChild( new RectangularPushButton( {
          content: resizingRectangle
        } ) );
        /*END*/
      } );
    </script>

    <h2 id="Checkboxes" class="index">Checkboxes</h2>

    <h3 id="CheckboxIcons" class="index">Icons</h3>

    <p>
      Checkboxes are <code>WidthSizable</code>, and act like a container for their label. For icons, this means you can
      pass in HBoxes to the label with two items, and the default justification will expand items out to the desired
      bounds:
    </p>

    <div id="CheckboxIcon-example"></div>
    <script>
      createSandbox( 'CheckboxIcon-example', ( scene, stepEmitter ) => {
        // import sun/js/Panel
        // import sun/js/Checkbox
        // import scenery-phet/js/PhetFont

        const resizingRectangle = new Rectangle( {
          fill: 'green',
          rectHeight: 15
        } );

        let elapsedTime = 0;
        stepEmitter.addListener( dt => {
          elapsedTime += dt;

          const minWidth = 30;
          const maxWidth = 200;
          resizingRectangle.rectWidth = ( minWidth + maxWidth ) / 2 + Math.cos( elapsedTime ) * ( maxWidth - minWidth ) / 2;
        } );
        /*START*/

        scene.addChild( new Panel( new VBox( {
          align: 'left',
          stretch: true,
          spacing: 5,
          children: [
            new Text( 'Checkbox Icons', { font: new PhetFont( { size: 14, weight: 'bold' } ) } ),
            new Checkbox( new BooleanProperty( false ), new HBox( {
              spacing: 10,
              children: [
                new Text( 'First', {
                  font: new PhetFont( 12 )
                } ),
                new Rectangle( 0, 0, 14, 14, { fill: 'red' } )
              ]
            } ), {
              boxWidth: 14
            } ),
            new Checkbox( new BooleanProperty( false ), new HBox( {
              spacing: 10,
              children: [
                new Text( 'Second', {
                  font: new PhetFont( 12 )
                } ),
                new Rectangle( 0, 0, 14, 14, { fill: 'blue' } )
              ]
            } ), {
              boxWidth: 14
            } ),
            resizingRectangle
          ]
        } ) ) );

        /*END*/
      } );
    </script>

    <h3 id="CheckboxIndentation" class="index">Indentation</h3>

    <p>
      Margins can be used for indenting checkboxes:
    </p>

    <div id="CheckboxIndentedIcon-example"></div>
    <script>
      createSandbox( 'CheckboxIndentedIcon-example', ( scene, stepEmitter ) => {
        // import sun/js/Panel
        // import sun/js/Checkbox
        // import scenery-phet/js/PhetFont

        const resizingRectangle = new Rectangle( {
          fill: 'green',
          rectHeight: 15
        } );

        let elapsedTime = 0;
        stepEmitter.addListener( dt => {
          elapsedTime += dt;

          const minWidth = 30;
          const maxWidth = 200;
          resizingRectangle.rectWidth = ( minWidth + maxWidth ) / 2 + Math.cos( elapsedTime ) * ( maxWidth - minWidth ) / 2;
        } );
        /*START*/

        scene.addChild( new Panel( new VBox( {
          align: 'left',
          stretch: true,
          spacing: 5,
          children: [
            new Text( 'Checkbox Icons', { font: new PhetFont( { size: 14, weight: 'bold' } ) } ),
            new Checkbox( new BooleanProperty( false ), new HBox( {
              spacing: 10,
              children: [
                new Text( 'First', {
                  font: new PhetFont( 12 )
                } ),
                new Rectangle( 0, 0, 14, 14, { fill: 'red' } )
              ]
            } ), {
              boxWidth: 14
            } ),
            new Checkbox( new BooleanProperty( false ), new HBox( {
              spacing: 10,
              children: [
                new Text( 'Second', {
                  font: new PhetFont( 12 )
                } ),
                new Rectangle( 0, 0, 14, 14, { fill: 'blue' } )
              ]
            } ), {
              boxWidth: 14,
              layoutOptions: {
                leftMargin: 20
              }
            } ),
            resizingRectangle
          ]
        } ) ) );

        /*END*/
      } );
    </script>

    <h2 id="Transforms" class="index">Transforms</h2>

    <p>
      Sizable nodes within layout containers CAN be transformed in some specific ways that will be respected. It's
      generally preferred to avoid transforms on direct children of layout containers, but sometimes it's necessary.
    </p>

    <h3 id="TransformsScale" class="index">Scale</h3>

    <p>
      Scale should be maintained and respected by layout containers. In cases like these, the
      <code>preferredWidth</code>
      and <code>localPreferredWidth</code> of sizable nodes will be different (based on the current transform).
      In general, set <code>preferredWidth</code> as normal, regardless of the scale.
    </p>

    <div id="TransformsScale-example"></div>
    <script>
      createSandbox( 'TransformsScale-example', ( scene, stepEmitter ) => {
        // import sun/js/Panel
        // import sun/js/Checkbox
        // import scenery-phet/js/PhetFont

        const resizingRectangle = new Rectangle( {
          fill: 'green',
          rectHeight: 15
        } );

        let elapsedTime = 0;
        stepEmitter.addListener( dt => {
          elapsedTime += dt;

          const minWidth = 100;
          const maxWidth = 300;
          resizingRectangle.rectWidth = ( minWidth + maxWidth ) / 2 + Math.cos( elapsedTime ) * ( maxWidth - minWidth ) / 2;
        } );
        /*START*/

        scene.addChild( new Panel( new VBox( {
          align: 'left',
          stretch: true,
          spacing: 5,
          children: [
            new Checkbox( new BooleanProperty( false ), new HBox( {
              spacing: 10,
              children: [
                new Text( 'Scale: 1', {
                  font: new PhetFont( 12 )
                } ),
                new Rectangle( 0, 0, 14, 14, { fill: 'red' } )
              ]
            } ), {
              boxWidth: 14
            } ),
            new Checkbox( new BooleanProperty( false ), new HBox( {
              spacing: 10,
              children: [
                new Text( 'Scale: 2', {
                  font: new PhetFont( 12 )
                } ),
                new Rectangle( 0, 0, 14, 14, { fill: 'magenta' } )
              ]
            } ), {
              scale: 2,
              boxWidth: 14
            } ),
            new Checkbox( new BooleanProperty( false ), new HBox( {
              spacing: 10,
              children: [
                new Text( 'Scale: 0.5', {
                  font: new PhetFont( 12 )
                } ),
                new Rectangle( 0, 0, 14, 14, { fill: 'blue' } )
              ]
            } ), {
              scale: 0.5,
              boxWidth: 14
            } ),
            resizingRectangle
          ]
        } ) ) );

        /*END*/
      } );
    </script>

    <h3 id="TransformsReflection" class="index">Reflection</h3>

    <p>
      Reflection is also supported (but hopefully rarely needed)
    </p>

    <div id="TransformsReflection-example"></div>
    <script>
      createSandbox( 'TransformsReflection-example', ( scene, stepEmitter ) => {
        // import sun/js/Panel
        // import sun/js/Checkbox
        // import scenery-phet/js/PhetFont

        const resizingRectangle = new Rectangle( {
          fill: 'green',
          rectHeight: 15
        } );

        let elapsedTime = 0;
        stepEmitter.addListener( dt => {
          elapsedTime += dt;

          const minWidth = 30;
          const maxWidth = 200;
          resizingRectangle.rectWidth = ( minWidth + maxWidth ) / 2 + Math.cos( elapsedTime ) * ( maxWidth - minWidth ) / 2;
        } );
        /*START*/

        scene.addChild( new Panel( new VBox( {
          align: 'left',
          stretch: true,
          spacing: 5,
          children: [
            new Checkbox( new BooleanProperty( false ), new HBox( {
              spacing: 10,
              children: [
                new Text( 'Normal', {
                  font: new PhetFont( 12 )
                } ),
                new Rectangle( 0, 0, 14, 14, { fill: 'red' } )
              ]
            } ), {
              boxWidth: 14
            } ),
            new Checkbox( new BooleanProperty( false ), new HBox( {
              spacing: 10,
              children: [
                new Text( 'Reflected', {
                  font: new PhetFont( 12 )
                } ),
                new Rectangle( 0, 0, 14, 14, { fill: 'magenta' } )
              ]
            } ), {
              matrix: Matrix3.scaling( -1, 1 ),
              boxWidth: 14
            } ),
            resizingRectangle
          ]
        } ) ) );

        /*END*/
      } );
    </script>

    <h3 id="Rotation" class="index">Rotation</h3>

    <p>
      Rotation is also supported.
    </p>

    <div id="Rotation-example"></div>
    <script>
      createSandbox( 'Rotation-example', ( scene, stepEmitter ) => {
        // import scenery-phet/js/ArrowShape
        // import scenery-phet/js/Panel

        const resizingRectangle = new Rectangle( {
          fill: 'green',
          rectHeight: 15
        } );

        let elapsedTime = 0;
        stepEmitter.addListener( dt => {
          elapsedTime += dt;

          const minWidth = 30;
          const maxWidth = 200;
          resizingRectangle.rectWidth = ( minWidth + maxWidth ) / 2 + Math.cos( elapsedTime ) * ( maxWidth - minWidth ) / 2;
        } );

        /*START*/

        scene.addChild( new Panel( new VBox( {
          align: 'left',
          stretch: true,
          spacing: 5,
          children: [
            new Checkbox( new BooleanProperty( false ), new HBox( {
              spacing: 10,
              children: [
                new Text( 'Normal', {
                  font: new PhetFont( 12 )
                } ),
                new Path( new ArrowShape( 0, 15, 0, 0 ), { fill: 'blue' } )
              ]
            } ), {
              boxWidth: 14
            } ),
            new Checkbox( new BooleanProperty( false ), new HBox( {
              spacing: 10,
              children: [
                new Text( 'Rotated', {
                  font: new PhetFont( 12 )
                } ),
                new Path( new ArrowShape( 0, 15, 0, 0 ), { fill: 'blue' } )
              ]
            } ), {
              matrix: Matrix3.affine( Math.cos( Math.PI / 2 ), -Math.sin( Math.PI / 2 ), 0,
                Math.sin( Math.PI / 2 ), Math.cos( Math.PI / 2 ), 0 ),
              boxWidth: 14
            } ),
            resizingRectangle
          ]
        } ) ) );
        /*END*/
      } );
    </script>

    <h2 id="FlowConstraint" class="index">Flow Constraint</h2>
    <h3 id="DisconnectedFlow" class="index">Disconnected Flow</h3>

    <p>
      Flow constraint allows a parent and child to have disconnected position and bounds.
    </p>

    <div id="DisconnectedFlow-example"></div>
    <script>
      createSandbox( 'DisconnectedFlow-example', ( scene, stepEmitter ) => {
        // import scenery-phet/js/PhetFont

        /*START*/
        const createLabeledBox = ( label, fill, width, height ) => {
          return new Rectangle( 0, 0, width, height, {
            stroke: 'black',
            fill: fill,
            children: [
              new Text( label, { font: new PhetFont( 14 ), left: 7, bottom: height - 7 } )
            ]
          } );
        };

        const firstChild = createLabeledBox( 'First child', '#faa', 150, 30 );
        const secondChild = createLabeledBox( 'Second child', '#afa', 150, 30 );
        const thirdChild = createLabeledBox( 'Third child', '#aaf', 150, 30 );

        firstChild.y = 50;

        const firstParent = new Node( {
          children: [
            firstChild,
            createLabeledBox( 'First parent', null, 200, 200 )
          ]
        } );
        const secondParent = new Node( {
          children: [
            secondChild,
            createLabeledBox( 'Second parent', null, 200, 200 )
          ],
          scale: 0.75
        } );
        const thirdParent = new Node( {
          children: [
            thirdChild,
            createLabeledBox( 'Third parent', null, 200, 200 )
          ],
          scale: 0.5
        } );

        const containerNode = new Node( {
          children: [ firstParent, secondParent, thirdParent ],
          localBounds: new Bounds2( 0, 0, 1200, 400 )
        } );

        scene.addChild( containerNode );

        let elapsedTime = 0;
        stepEmitter.addListener( dt => {
          elapsedTime += dt;

          secondParent.x = 500;
          secondParent.y = 150;
          firstParent.x = 250;
          firstParent.y = 100 + Math.cos( elapsedTime ) * 100;
          thirdParent.x = secondParent.centerX + 150 + Math.cos( elapsedTime ) * 100;
          thirdParent.y = secondParent.centerY + Math.sin( elapsedTime ) * 100;
        } );

        const constraint = new FlowConstraint( scene, {
          layoutOriginProperty: new Vector2Property( new Vector2( 400, 100 ) )
        } );
        constraint.spacing = 10;
        constraint.insertCell( 0, new FlowCell( constraint, firstChild, null ) );
        constraint.insertCell( 1, new FlowCell( constraint, secondChild, null ) );
        constraint.insertCell( 2, new FlowCell( constraint, thirdChild, null ) );
        constraint.updateLayout();
        /*END*/

      } );
    </script>

    <h3 id="FlowStressTest" class="index">Flow Stress Test</h3>

    <p>
      300 rectangles are created with random sizes inside a Flowbox to demonstrate a horizontal orientation with
      wrapping.
      Stress test demonstrates how layout successfully handles a variety of rectangle sizes while still aligning content
      as expected.
    </p>

    <div id="FlowStressTest-example"></div>
    <script>
      createSandbox( 'FlowStressTest-example', ( scene, stepEmitter ) => {

        /*START*/
        scene.addChild( new FlowBox( {
          orientation: 'horizontal',
          wrap: true,
          justify: 'left',
          children: _.range( 0, 300 ).map( n => new Rectangle( 0, 0, dotRandom.nextDoubleBetween( 2, 20 ), dotRandom.nextDoubleBetween( 10, 50 ), {
            fill: colors[ dotRandom.nextIntBetween( 2, 8 ) ]
          } ) ),
          preferredWidth: 500
        } ) );
        /*END*/

      } );
    </script>

    <h2 id="GridConstraint" class="index">Grid Constraint</h2>
    <h3 id="GridStressTest" class="index">Grid Stress Test</h3>

    <p>
      900 rectangles are created with random sizes inside a gridBox. Each rectangle is inside its own cell.
      Stress test demonstrates how layout successfully adjusts row and column sizes to accommodate a variety
      of rectangle sizes.
    </p>

    <div id="GridStressTest-example"></div>
    <script>
      createSandbox( 'GridStressTest-example', ( scene, stepEmitter ) => {

        /*START*/
        scene.addChild( new GridBox( {
          autoColumns: 30,
          children: _.range( 0, 30 * 30 ).map( () => {
            return new Rectangle( 0, 0, dotRandom.nextDoubleBetween( 2, 20 ), dotRandom.nextDoubleBetween( 2, 20 ), {
              fill: colors[ dotRandom.nextIntBetween( 2, 8 ) ]
            } );
          } )
        } ) );
        /*END*/

      } );
    </script>


    <h2 id="ManualConstraint" class="index">Manual Constraint</h2>

    <h3 id="DisconnectedNodesAlignment" class="index">Disconnected Nodes Alignment</h3>
    <p>
      A resizer animates to demonstrate how Manual Constraint can connect the layout of two separate nodes. The
      position of the leftText stays aligned with the position of the rightText as the rightText's y coordinate changes.
    </p>

    <div id="DisconnectedNodesAlignment-example"></div>
    <script>
      createSandbox( 'DisconnectedNodesAlignment-example', ( scene, stepEmitter ) => {
        // import scenery-phet/js/PhetFont

        /*START*/
        const rightText = new Text( 'Text aligned on right', new PhetFont( 12 ) );
        const leftText = new Text( 'Text aligned on left', new PhetFont( 12 ) );

        const resizer = new Rectangle( {
          fill: 'green',
          rectWidth: 30
        } );

        let elapsedTime = 0;
        stepEmitter.addListener( dt => {
          elapsedTime += dt;

          const minHeight = 50;
          const maxHeight = 200;
          resizer.rectHeight = ( minHeight + maxHeight ) / 2 + Math.cos( elapsedTime ) * ( maxHeight - minHeight ) / 2;
        } );

        const panel = new Panel( new FlowBox( {
          orientation: 'vertical',
          align: 'left',
          spacing: 5,
          children: [
            resizer,
            rightText
          ]
        } ) );


        const alignBox = new AlignBox( panel, { margin: 10, xAlign: 'right', yAlign: 'top' } );

        const node = new Node();

        // Can create the constraint before things are connected (it will listen)
        ManualConstraint.create( node, [ leftText, rightText, panel ], ( leftProxy, rightProxy, panelProxy ) => {
          leftProxy.centerY = rightProxy.centerY;
          leftProxy.right = panelProxy.left - 10;
        } );

        node.children = [ leftText, alignBox ];

        scene.addChild( new VBox( { children: [ node ], preferredHeight: 250 } ) );
        /*END*/

      } );
    </script>

    <h3 id="DynamicCentering" class="index">DynamicCentering</h3>
    <p>This example comes from a use case in Greenhouse Effect. In this sim the developer was looking for a way to dynamically center a button in a play area Observation Window.
      Manual Constraint became the perfect tool to accomplish this. By triggering a callback each time the bounds of the button changed, Manual Constraint created seamless centering
      based off of another node's layout bounds.</p>

    <p>Use <code>ManualConstraint.create</code> to set up your custom positioning. The first argument is the ancestorNode (this node must be common to all
      nodes we will be listening to). The second argument is an array of nodes you want to trigger the manual constraint and/or manipulate in the constraint. The third argument is a callback
      that will be triggered anytime the bounds of our nodes in the second argument change.
    </p>
    <div id="DynamicCentering-example"></div>
    <script>
      createSandbox( 'DynamicCentering-example', ( scene, stepEmitter ) => {
        // import scenery-phet/js/PhetFont

        const resizingRectangle = new Rectangle( {
          fill: 'green',
          rectHeight: 15
        } );

        let elapsedTime = 0;
        stepEmitter.addListener( dt => {
          elapsedTime += dt;

          const minWidth = 30;
          const maxWidth = 200;
          resizingRectangle.rectWidth = ( minWidth + maxWidth ) / 2 + Math.cos( elapsedTime ) * ( maxWidth - minWidth ) / 2;
        } );

        /*START*/
        const observationWindowFrame = new Rectangle( 0, 0, 500, 300, { stroke: 'black' } );
        const resizingPushButton = new RectangularPushButton( { content: resizingRectangle } );

        const observationWindow = new Node( { children: [ observationWindowFrame, resizingPushButton ] } );

        ManualConstraint.create( observationWindow, [ resizingPushButton ], ( pushButtonProxy ) => {
          pushButtonProxy.center = observationWindowFrame.center
        } );



        scene.addChild( observationWindow );
        /*END*/
      } )
    </script>

    <h3 id="ConditionalAlignment" class="index">Conditional Alignment</h3>
    <p>This example comes from a use case in Build a Nucleus</p>

    <h3 id="DynamicLabels" class="index">Dynamic Labels</h3>
    <p>This example comes from a use case in Density. In this sim an arrow shows where a cube lands on the density spectrum. A label must accompany this arrow adding more clarity to to the data a user is seeing.
      <code>ManualConstraint.create</code> allows developers to connect two separate nodes together so that when a node's x or y position changes another node can respond accordingly. </p>

    <div id="DynamicLabels-example"></div>
    <script>
      createSandbox( 'DynamicLabels-example', ( scene, stepEmitter ) => {
        // import scenery-phet/js/PhetFont

        const line = new Line( 0, 0, 400, 0, { stroke: 'black' } );
        const leftLineEnd = new Circle( 3, { fill: 'black', centerX: line.x1, centerY: 0 } )
        const rightLineEnd = new Circle( 3, { fill: 'black', centerX: line.x2, centerY: 0 } )

        /*START*/
        const speedLine = new Node( { children: [ line, leftLineEnd, rightLineEnd ] } );
        const hyperspeedLabel = new Text( 'Hyperspeed', { font: new PhetFont( { size: 14, weight: 'bold' } ) } );
        const parkedLabel = new Text( 'Parked', { font: new PhetFont( { size: 14, weight: 'bold' } ) } );

        const arrow = new ArrowNode( 0, -35, 0, -10 );
        const label = new Text( 'Millenium Falcon', { font: new PhetFont( { size: 14, weight: 'bold' } ), centerY: -42 } );

        const speedHBox = new HBox( { children: [ parkedLabel, speedLine, hyperspeedLabel  ], spacing: 10 } );
        const speedNode = new Node( { children: [ label, arrow, speedHBox ] } );

        ManualConstraint.create( speedNode, [ label, arrow ], ( labelProxy, arrowProxy ) => {
          labelProxy.centerX = arrowProxy.centerX;
        } )

        scene.addChild( speedNode )
        /*END*/

        let elapsedTime = 0;
        stepEmitter.addListener( dt => {
          elapsedTime += dt;

          const minX = speedLine.left;
          const maxX = speedLine.right;
          arrow.x = ( maxX + minX ) / 2 + Math.cos( elapsedTime ) * ( minX - maxX ) / 2;
        } );
      } );
    </script>

    <h2 id="AlignGroup" class="index">Align Group</h2>

    <h3 id="CrossScreenAlignment" class="index">Cross Screen Alignment</h3>
    <p>It is common for PhET sims to have panels that exist across multiple screens. These panels may have different content but a design standard is that
    their width/height matches across those screens. This example shows how AlignGroup can easily accomplish this with little effort on the developer's part.
    This example may require a bit of imagination. Imagine each Panel is located in a different screen, and notice how their widths and heights synchronize.</p>
    <div id="CrossScreenAlignment-example"></div>
    <script>
      createSandbox( 'CrossScreenAlignment-example', ( scene, stepEmitter ) => {
        // import scenery-phet/js/PhetFont

        const resizingRectangle = new Rectangle( {
          fill: 'green',
          rectHeight: 15
        } );

        let elapsedTime = 0;
        stepEmitter.addListener( dt => {
          elapsedTime += dt;

          const minWidth = 30;
          const maxWidth = 200;
          resizingRectangle.rectWidth = ( minWidth + maxWidth ) / 2 + Math.cos( elapsedTime ) * ( maxWidth - minWidth ) / 2;
        } );

        /*START*/
        // This AlignGroup might be declared in a parent screen view, or another sim-wide accessible class.
        const alignGroup = new AlignGroup( { matchHorizontal: true, matchVertical: true } );

        // Screen 1 content:
        const threeStoogesAlignBox = new AlignBox( new VBox( {
          children: [
            new Checkbox( new BooleanProperty( false ), new Text( 'Moe', new PhetFont( 12 ) ) ),
            new Checkbox( new BooleanProperty( false ), new Text( 'Larry', new PhetFont( 12 ) ) ),
            new Checkbox( new BooleanProperty( false ), new Text( 'Curly', new PhetFont( 12 ) ) ),
            resizingRectangle
          ]
        } ), { group: alignGroup } );

        const threeStoogesPanel = new Panel( threeStoogesAlignBox );

        const screen1 = new Node( { children: [ threeStoogesPanel ], x: 0 } );

        // Screen 2 content:
        const threeMusketeersAlignBox = new AlignBox( new VBox( {
          children: [
            new Checkbox( new BooleanProperty( false ), new Text( 'Athos', new PhetFont( 12 ) ) ),
            new Checkbox( new BooleanProperty( false ), new Text( 'Porthos', new PhetFont( 12 ) ) ),
            new Checkbox( new BooleanProperty( false ), new Text( 'Aramis', new PhetFont( 12 ) ) )
          ]
        } ), { group: alignGroup } );

        const threeMusketeersPanel = new Panel( threeMusketeersAlignBox );

        const screen2 = new Node( { children: [ threeMusketeersPanel ], x: 300 } );

        scene.addChild( new Node( { children: [ screen1, screen2 ] } ) );
        /*END*/
      })
    </script>

    <h2 id="Origin" class="index">Origin</h2>

    <h3 id="AsymmetricalComponentAlignment"></h3>
    <p>
      As seen in fractions LabScreen
    </p>

    <h3 id="OriginOrientation" class="index">Origin Orientation</h3>
    <p>
      Demos the orientation feature for alignment in flow and grid layouts. Essentially the x=0 or y=0 point of the
      nodes
      are placed in the same vertical or horizontal line when 'origin' is used for alignment.
    </p>

    <div id="Origin-example"></div>
    <script>
      createSandbox( 'Origin-example', ( scene, stepEmitter ) => {
        // import scenery-phet/js/PhetFont

        const normalText = ( str, options = {} ) => new Text( str, merge( {
          font: new PhetFont( 12 )
        }, options ) );
        const sectionText = ( str, options = {} ) => new Text( str, merge( {
          font: new PhetFont( { size: 14, weight: 'bold' } )
        }, options ) );
        const bigText = ( str, options = {} ) => new Text( str, merge( {
          font: new PhetFont( { size: 18, weight: 'bold' } )
        }, options ) );

        /*START*/
        const originSize = 50;
        const originNode = new Path( new Shape().moveTo( -originSize, 0 ).lineTo( originSize, 0 ).moveTo( 0, originSize ).lineTo( 0, -originSize ), {
          stroke: 'rgba(0,0,0,0.3)'
        } );

        const flowBox = new FlowBox( {
          orientation: 'horizontal',
          align: 'origin',
          spacing: 5,
          lineSpacing: 5,
          children: [
            new Circle( 20, { fill: 'rgba(255,0,0,0.3)' } ),
            bigText( 'Text' ),
            normalText( 'Text' ),
            new Circle( 20, { fill: 'rgba(255,0,0,0.3)' } ),
            bigText( 'Text' ),
            normalText( 'text' ),
            new Circle( 20, { fill: 'rgba(255,0,0,0.3)' } ),
            bigText( 'Text' ),
            normalText( 'text' ),
            new Circle( 20, { fill: 'rgba(255,0,0,0.3)' } ),
            bigText( 'Text' ),
            normalText( 'text' )
          ],
          wrap: true,
          preferredWidth: 170,
          widthSizable: false,
          justify: 'left'
        } );

        const gridBox = new GridBox( {
          xAlign: 'origin',
          yAlign: 'origin',
          children: [
            new Circle( 20, { fill: 'rgba(255,0,0,0.3)', layoutOptions: { column: 0, row: 0 } } ),
            new Circle( 10, { fill: 'rgba(255,0,0,0.3)', layoutOptions: { column: 1, row: 0 } } ),
            new Circle( 15, { fill: 'rgba(255,0,0,0.3)', layoutOptions: { column: 0, row: 1 } } ),
            new Circle( 25, { fill: 'rgba(255,0,0,0.3)', layoutOptions: { column: 1, row: 1 } } )
          ]
        } );

        const content = new GridBox( {
          spacing: 15,
          children: [
            sectionText( 'FlowBox', { layoutOptions: { column: 0, row: 0 } } ),
            sectionText( 'GridBox', { layoutOptions: { column: 1, row: 0 } } ),
            new Node( {
              children: [
                originNode,
                flowBox
              ],
              layoutOptions: { column: 0, row: 1, yAlign: 'origin' }
            } ),
            new Node( {
              children: [
                new GridBackgroundNode( gridBox.constraint ),
                originNode,
                gridBox
              ],
              layoutOptions: { column: 1, row: 1, yAlign: 'origin' }
            } )
          ]
        } );

        scene.addChild( new AlignBox( content, { xAlign: 'center', yAlign: 'center' } ) );
        /*END*/

      } );
    </script>

    <h2 id="Separators" class="index">Separators</h2>
    <h3 id="DisappearingNode" class="index">Disappearing Node</h3>

    <p>
      A disappearing node demonstrates how separators dynamically react to content being added or removed in a panel.
    </p>

    <div id="DisappearingNode-example"></div>
    <script>
      createSandbox( 'DisappearingNode-example', ( scene, stepEmitter ) => {
        // import scenery-phet/js/PhetFont

        const result = new Rectangle( {
          fill: 'green',
          rectWidth: 150,
          rectHeight: 100
        } );

        let elapsedTime = 0;
        stepEmitter.addListener( dt => {
          elapsedTime += dt;
          result.visible = Math.floor( elapsedTime ) % 2 === 0;
        } );

        /*START*/

        const panel = new Panel( new FlowBox( {
          orientation: 'vertical',
          align: 'left',
          spacing: 5,
          children: [
            new HSeparator(),
            new Text( 'Disappearing node?:', { font: new PhetFont( { size: 14, weight: 'bold' } ) } ),
            new HSeparator(),
            result,
            new HSeparator()
          ]
        } ) );
        scene.addChild( new VBox( { children: [ panel ], preferredHeight: 150 } ) );
        /*END*/

      } );
    </script>

  </div>
  <div class="span2"></div>
</div>

<script>
  generateAPIList();
</script>
</body>
</html>
